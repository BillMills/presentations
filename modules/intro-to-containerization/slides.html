<section data-background="images/title-whale.png" class="blue_bg">
	<h2>Introduction to Containerization with Docker</h2>
	<aside class="notes">

	</aside>
</section>
                
<section data-background="#1AAAF8" class="blue_bg">
    <h2>Warm up exercise:</h2>
    <a href='https://www.katacoda.com/docker-training/courses/containerization-101'>https://www.katacoda.com/docker-training/courses/containerization-101</a>
    <p>"Starting and Inspecting a Container"</p>

    <aside class="notes">
    	- Let's start by firing up a container right away, and exploring a few details of exactly what's going on when we start a container.
    </aside>
</section>

<section data-background="#1AAAF8" class="blue_bg">
    <h2>Container Isolation</h2>
    <img src='images/pid-tree.png' style='float:left; max-width:50%'></img>
    <ul style='float:right; max-width: 47%;'>
        <li>Containers are formed by namespacing resources from the host machine - PID tree, kernel, network etc</li>
        <li>Command specified by `docker run` is always PID 1 inside the container; will have a higher PID on the host machine but is <i>part of the same PID tree</i></li>
        <li>Container only runs as long as the process specified in `docker run`.</li>
        <li>`containerd` is in charge of starting, stopping and destroying containers; built on top of runc (https://runc.io) and `libcontainer`.</li>
    </ul>

    <aside class="notes">
         - besides the basic syntax for starting a container, the first example illustrated the contrast between the pid tree inside and outside of the container. Unlike VMs, Docker containers don't create a whole new virtual operating system; they essentially partition the kernel of the host using kernel and network namespaces, among other core linux features.<br>
    </aside>
</section>

<section data-background="#1AAAF8" class="blue_bg">
    <h2>Exercises: Working with Containers</h2>
    <a href='https://www.katacoda.com/docker-training/courses/containerization-101'>https://www.katacoda.com/docker-training/courses/containerization-101</a>
    <p>Please do all the scenarios remaining in this unit. Work with the people sitting near you, ask questions and talk about anything that is unclear! Topics:</p>
    <ul>
        <li>Creating, starting, stopping and deleting containers</li>
        <li>Writing to the container file system</li>
        <li>Investigating container logs and metadata</li>
    </ul>

    <aside class="notes">
        - Most of the rest of container basics are syntax; rather than a show-and-tell, go ahead and jump in by following the rest of the demos on Katacoda. Work with your colleagues and talk about everything you see!
    </aside>
</section>

<section data-background="#1AAAF8" class="blue_bg">
    <h2>Container Basics Takeaways</h2>
    <ul>
        <li>Containers all run a single primary process as their own PID 1; stop that process, and the container itself stops.</li>
        <li>Writing to a container writes only to that instance of the container - not the underlying image.</li>
        <li>Create new containers with `docker run`; destroy old ones with `docker rm`</li>
        <li>Start and stop containers with `docker start`, `docker stop` and `docker kill`</li>
        <li>Interact with containers via `docker exec` and `docker attach`</li>
        <li>Investigate container's PID 1 with `docker logs`, the container itself with `docker inspect`, and all containers with `docker ps`</li>
    </ul>

    <aside class="notes">
        - The key conceptual take-aways for container basics are the first two points; the container's main process, which it labels PID 1, will stop the container when it itself stops; and writing to the container's file system writes only to that container, not the underlying image; soon we'll learn more about these underlying images, and how to manipulate them.<br>
        - Everything else we learned in this unit is basic creation, deletion and investigation syntax.<br>
    </aside>
</section>